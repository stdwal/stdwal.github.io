<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 寻找两个有序数列的中间值问题 · stdwal</title><meta name="description" content="寻找两个有序数列的中间值问题 - stdwal"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://stdwal.github.io/atom.xml" title="stdwal"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/messages/" target="_self" class="nav-list-link">MESSAGES</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">寻找两个有序数列的中间值问题</h1><div class="post-info">2018年4月4日</div><div class="post-content"><p>以升序给定两个数列，求两个数列中的中间值问题。</p>
<a id="more"></a>
<p>例如：</p>
<p>11 12 13 14<br>9 10 15 16 17</p>
<p>这两个序列，它们的中间值为13.</p>
<p>最常见的做法是将这两个序列放入同一个数组中排序，然后输出第(a+b)/2个元素.</p>
<p>但即使是O(logn)的快排在大规模数据里也难以在一秒内返回答案，我们需要利用数组有序的特点制定一种O(logn)的算法策略。</p>
<p>我们把这个中值问题扩展到寻找第K小的值问题，等价于在两个数组中挑选出最小的K个元素。由于给定的数组已经按从小到大排序，通过比较两个数组各自的第K/2个元素可以将问题规模减小K/2。</p>
<p><em>注：假设a[i]为a中第i个元素。</em></p>
<p>定义函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findkth(int a[], int b[], int k)</span><br></pre></td></tr></table></figure></p>
<p>表示寻找到并返回数组a，b中第K小的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[k/<span class="number">2</span>] &lt; b[k/<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> findkth(a + k / <span class="number">2</span>, b, k - k / <span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k/<span class="number">2</span>] == b[k/<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[k/<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findkth(a, b + k / <span class="number">2</span>, k - k / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种情况是a的第k/2个元素小于b的第k/2个元素，那么将a中的前k/2个元素挑选出来，并在剩下的数组a，b中挑选出后k/2个元素。</p>
<p>如果数组a，b各自的第k/2个元素相等，则将a中前k/2个元素挑出，b中前k/2个元素也挑出，这样第k小的元素即是a[k/2]（或b[k/2]）。</p>
<p>再考虑基本情况：</p>
<ul>
<li><p>当数组a为空时，b[k]为第k小的元素。</p>
</li>
<li><p>当k为1时选择数组a，b中最小的一个，即min(a[0], b[0])。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findkth</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; n2) &#123;</span><br><span class="line">        <span class="keyword">return</span> findkth(b, a, n2, n1, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> min(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ath = min(k / <span class="number">2</span>, n1);</span><br><span class="line">    <span class="keyword">int</span> bth = k - ath;</span><br><span class="line">    <span class="keyword">if</span> (a[ath<span class="number">-1</span>] &lt; b[bth<span class="number">-1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> findkth(a + ath, b, n1 - ath, n2, k - ath);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[ath<span class="number">-1</span>] == b[bth<span class="number">-1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[ath<span class="number">-1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findkth(a, b + bth, n1, n2 - bth, k - bth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/14/data-structures-and-algorithm-analysis-in-c/" class="prev">上一篇</a><a href="/2018/04/01/the-most-merciful/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'stdwal';
var disqus_identifier = '2018/04/04/two-arrays-median/';
var disqus_title = '寻找两个有序数列的中间值问题';
var disqus_url = 'https://stdwal.github.io/2018/04/04/two-arrays-median/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//stdwal.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2018 <a href="https://stdwal.github.io">stdwal</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>